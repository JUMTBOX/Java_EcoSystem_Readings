## 2. 서블릿 컨테이너

```java
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server_0 () {

  static void main(String[] args) throws IOException {
    Server_0 server = new Server_0();
	server.boot();
  }
  
  private ServerSocket serverSocket;
  
  private void boot () throws IOException {
	serverSocket = new ServerSocket(8000);
	Socket socket = serverSocket.accept();
	InputStream inputStream = socket.getInputStream();
	OutputStream outputStream = socket.getOutputStream();
	  
	int oneInt;
	while(-1 != (oneInt = inputStream.read())) {
	  System.out.println((char) oneInt);
	}
	  
	outputStream.close();
	inputStream.close();
	socket.close();
  }
}
```
- ```InputStream```의 ```read```메서드는 스트림의 끝에 다다를 경우, 즉 소켓에서 얻은 스트림의 연결이 끊어질 경우에 -1을 반환
- 이와 같은 종료 조건은 ```클라이언트-서버``` 구조에서 사용하기 어렵다. 메시지의 끝을 연결 종료로 파악할 수 밖에 없다면, 양방향 통신이 필요할 때 요청에 대한 응답을 보낼 수 없기 때문
- 따라서 서블릿 컨테이너는 스트림을 사용해 소켓에서 한 바이트씩 읽어들이면서 어느 시점에서 읽기를 중단하고 지금까지 받은 내용을 기반으로 요청 메시지를 구상할지 판단해야한다.
- HTTP프로토콜에 대해 이런 상태를 분석하는 코드를 HTTP상태 기계라고 한다.


**HTTP GET 요청 처리기**
- 메시지 바디가 없는 GET 요청의 경우, HTTP 메시지의 종료 시점을 결정하는 데 있어 행 구분자(CRLF) 위치를 파악하는 것이 무엇보다 중요하다.
- 다음은 행 구분자를 고려한 Server_1 코드다.
```java
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server_1 () {

  static void main(String[] args) throws IOException {
	Server_1 server = new Server_1();
	server.boot();
  }
  
  public static final byte CR = '\r';
  public static final byte LF = '\n';
  private ServerSocket serverSocket;

  private void boot () throws IOException {
	serverSocket = new ServerSocket(8000);
	Socket socket = serverSocket.accept();
	InputStream inputStream = socket.getInputStream();
	
	int oneInt;
	byte oldByte = (byte) -1; 
    StringBuilder sb = new StringBuilder();
	int lineNumber = 0;
	
	while(-1 != (oneInt = inputStream.read())) {
	  byte thisByte = (byte) oneInt;
	  if(thisByte == Server_1.LF && oldByte == Server_1.CR) {
		/* CRLF가 완성되었으므로 직전 CRLF부터 여기까지 HTTP 메시지의 한 행이다. 
         * 아직 LF가 버퍼에 들어가기 전이므로 -2가 아닌 -1을 해준다.
         * */
        String oneLine = sb.substring(0, sb.length() -1);
		lineNumber ++;
	    System.out.printf("%d: %s\n", lineNumber, oneLine);
		/* 내용이 없는 행 -> 메시지 헤더의 마지막인 경우 */
		if(oneLine.length() <= 0) {
		  System.out.println("[SYS] 내용이 없는 헤더, 즉 메시지 헤더의 끝");
		  break;
		}
		sb.setLength(0);
	  } else {
		sb.append(thisByte);
	  }
	  oldByte = oneInt;
	}
	inputStream.close();
	socket.close();
  }
}
```
- 메시지 바디는 행 기반 구조를 사용하지 않기 때문에 바이트의 묶음으로 처리해야한다.
- 메시지 헤더를 처리할 때 시작행을 특별하게 처리해 HTTP 메서드, 요청 URL, HTTP 버전 정보를 알아낸다.
- 메시지 헤더가 종료되면 메시지 바디를 읽을 것인지 종료할 것인지 결정 (GET,POST 고려)
- 메시지 바디를 읽는다면 "Content-Length" 헤더 값을 확인해 얼마나 읽어야 하는지 판단
- 이를 위해 읽어들인 메시지 헤더를 key-value pair로 분리하여 Map형식으로 저장

**버퍼의 사용**
- HTTP메시지와 같이 네트워크상으로 접근되는 자원은 로컬 머신을 기원으로 하는 자원과 달리, 언제나 안정적으로 접근 가능할 것이라 가정하기 힘들다.
- 그리하여 획득 가능한 시점에 가능한 만큼(버퍼를 사용해서라도) 최대한 얻어오는 '게걸스런'방식을 사용하는 것이 정당하다.
- 즉, 소켓에서 스트림을 읽어올 때 바이트 하나씩을 읽는 방식보다는 버퍼를 이용해 읽어들인 다음 처리하는 것이 낫다.

**DMA(Direct Memory Access) 와 java.nio 패키지**
- DMA 지원이 가능한 버스는 미리 메모리 영역의 일부를 할당해 하드웨어상의 데이터를 메모리상의 DMA 영역으로 전달시킬 수 있다.
- 이때 DMA 영역에 접근할 수 있다면 커널 여역에서 유저 영역으로의 복사를 줄일 수 있다. 이는 java.nio 패키지를 사용해 구현하고 있다.

**서블릿 관리자**
- 일반적으로 ```웹 어플리케이션이 무엇인가?```라는 질문에 ```하위에 WEB-INF 디렉터리를 가지는 디렉터리 구조이며 최상위 디렉터리는 해당 웹 컨텍스트의 최상위 문서 루트가 된다.```는 내용과 WEB-INF 아래 있는 web.xml에 서블릿 설정이 들어간다는 정도가 일반적인 답변이다.
- 하지만 서블릿 컨테이너의 입장에서 웹 어플리케이션은 독립적인 클래스로더를 공유하는 웹 프로그램의 모임의 하나이다.
- 서블릿 컨테이너는 웹 어플리케이션마다 독자적인 클래스로더를 유지한다. 따라서 두 개의 웹 어플리케이션에 풀 패키지명이 같은 클래스가 동시에 존재한다고 하더라도 문제없이 동작할 수 있다.
