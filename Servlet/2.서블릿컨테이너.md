## 2. 서블릿 컨테이너

```java
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server_0 () {

  static void main(String[] args) throws IOException {
    Server_0 server = new Server_0();
	server.boot();
  }
  
  private ServerSocket serverSocket;
  
  private void boot () throws IOException {
	serverSocket = new ServerSocket(8000);
	Socket socket = serverSocket.accept();
	InputStream inputStream = socket.getInputStream();
	OutputStream outputStream = socket.getOutputStream();
	  
	int oneInt;
	while(-1 != (oneInt = inputStream.read())) {
	  System.out.println((char) oneInt);
	}
	  
	outputStream.close();
	inputStream.close();
	socket.close();
  }
}
```
- ```InputStream```의 ```read```메서드는 스트림의 끝에 다다를 경우, 즉 소켓에서 얻은 스트림의 연결이 끊어질 경우에 -1을 반환
- 이와 같은 종료 조건은 ```클라이언트-서버``` 구조에서 사용하기 어렵다. 메시지의 끝을 연결 종료로 파악할 수 밖에 없다면, 양방향 통신이 필요할 때 요청에 대한 응답을 보낼 수 없기 때문
- 따라서 서블릿 컨테이너는 스트림을 사용해 소켓에서 한 바이트씩 읽어들이면서 어느 시점에서 읽기를 중단하고 지금까지 받은 내용을 기반으로 요청 메시지를 구상할지 판단해야한다.
- HTTP프로토콜에 대해 이런 상태를 분석하는 코드를 HTTP상태 기계라고 한다.


**HTTP GET 요청 처리기**
- 메시지 바디가 없는 GET 요청의 경우, HTTP 메시지의 종료 시점을 결정하는 데 있어 행 구분자(CRLF) 위치를 파악하는 것이 무엇보다 중요하다.
- 다음은 행 구분자를 고려한 Server_1 코드다.
```java
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server_1 () {

  static void main(String[] args) throws IOException {
	Server_1 server = new Server_1();
	server.boot();
  }
  
  public static final byte CR = '\r';
  public static final byte LF = '\n';
  private ServerSocket serverSocket;

  private void boot () throws IOException {
	serverSocket = new ServerSocket(8000);
	Socket socket = serverSocket.accept();
	InputStream inputStream = socket.getInputStream();
	
	int oneInt;
	byte oldByte = (byte) -1; 
    StringBuilder sb = new StringBuilder();
	int lineNumber = 0;
	
	while(-1 != (oneInt = inputStream.read())) {
	  byte thisByte = (byte) oneInt;
	  if(thisByte == Server_1.LF && oldByte == Server_1.CR) {
		/* CRLF가 완성되었으므로 직전 CRLF부터 여기까지 HTTP 메시지의 한 행이다. 
         * 아직 LF가 버퍼에 들어가기 전이므로 -2가 아닌 -1을 해준다.
         * */
        String oneLine = sb.substring(0, sb.length() -1);
		lineNumber ++;
	    System.out.printf("%d: %s\n", lineNumber, oneLine);
		/* 내용이 없는 행 -> 메시지 헤더의 마지막인 경우 */
		if(oneLine.length() <= 0) {
		  System.out.println("[SYS] 내용이 없는 헤더, 즉 메시지 헤더의 끝");
		  break;
		}
		sb.setLength(0);
	  } else {
		sb.append(thisByte);
	  }
	  oldByte = oneInt;
	}
	inputStream.close();
	socket.close();
  }
}
```
- 메시지 바디는 행 기반 구조를 사용하지 않기 때문에 바이트의 묶음으로 처리해야한다.
- 메시지 헤더를 처리할 때 시작행을 특별하게 처리해 HTTP 메서드, 요청 URL, HTTP 버전 정보를 알아낸다.
- 메시지 헤더가 종료되면 메시지 바디를 읽을 것인지 종료할 것인지 결정 (GET 고려)
- 메시지 바디를 읽는다면 "Content-Length" 헤더 값을 확인해 얼마나 읽어야 하는지 판단
- 이를 위해 읽어들인 메시지 헤더를 key-value pair로 분리하여 Map형식으로 저장