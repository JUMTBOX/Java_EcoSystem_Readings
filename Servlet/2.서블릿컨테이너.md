## 2. 서블릿 컨테이너

**HTTP 요청 처리**
- 메시지 바디가 없는 GET 요청의 경우, HTTP 메시지의 종료 시점을 결정하는 데 있어 행 구분자(CRLF) 위치를 파악하는 것이 중요하다.
- 메시지 바디는 행 기반 구조를 사용하지 않기 때문에 바이트의 묶음으로 처리해야한다.
- 메시지 헤더를 처리할 때 시작행을 특별하게 처리해 HTTP 메서드, 요청 URL, HTTP 버전 정보를 알아낸다.
- 메시지 바디를 읽는다면 "Content-Length" 헤더 값을 확인해 얼마나 읽어야 하는지 판단

**버퍼의 사용**
- HTTP메시지와 같이 네트워크상으로 접근되는 자원은 로컬 머신을 기원으로 하는 자원과 달리, 언제나 안정적으로 접근 가능할 것이라 가정하기 힘들다.
- 그리하여 획득 가능한 시점에 가능한 만큼(버퍼를 사용해서라도) 최대한 얻어오는 '게걸스런'방식을 사용하는 것이 정당하다.
- 즉, 소켓에서 스트림을 읽어올 때 바이트 하나씩을 읽는 방식보다는 버퍼를 이용해 읽어들인 다음 처리하는 것이 낫다.

**DMA(Direct Memory Access) 와 java.nio 패키지**
- DMA 지원이 가능한 버스는 미리 메모리 영역의 일부를 할당해 하드웨어상의 데이터를 메모리상의 DMA 영역으로 전달시킬 수 있다.
- 이때 DMA 영역에 접근할 수 있다면 커널 여역에서 유저 영역으로의 복사를 줄일 수 있다. 이는 java.nio 패키지를 사용해 구현하고 있다.

**서블릿 관리자**
- 서블릿 컨테이너의 입장에서 웹 어플리케이션은 독립적인 클래스로더를 공유하는 웹 프로그램의 모임의 하나이다.
- 서블릿 컨테이너는 웹 어플리케이션마다 독자적인 클래스로더를 유지한다. 따라서 두 개의 웹 어플리케이션에 풀 패키지명이 같은 클래스가 동시에 존재한다고 하더라도 문제없이 동작할 수 있다.
- 명세의 요구사항은 아니지만 성능 문제를 고려한다면 서블릿 컨테이너는 웹 어플리케이션이 배치 될 때 미리 로딩해야 할 서블릿 인스턴스를 캐시 처리하는 것이 일반적이다.
- 캐시를 통해 요청시마다 동일한 서블릿을 클래스로더에서 반복해서 인스턴스화하는 것을 회피할 수 있고, 이를 위해 각 어플리케이션마다 서블릿 관리자가 존재한다.

1. 웹 어플리케이션 하나가 서블릿 컨테이너 안으로 배치되면 서블릿 컨테이너는 먼저 해당 웹 어플리케이션 전용 클래스로더를 생성
2. 그 후 ```WEB-INF/classes``` 디렉터리와 ```WEB-INF/lib``` 디렉터리 내에 있는 클래스 파일과 ```.jar```아카이브 파일들을 해당 클래스로더를 사용해 로딩한다.

**HTTP요청이 서블릿에 도달하기까지**
- 앞서 메시지 헤더의 첫 행을 시작행이라는 이름으로 특별하게 취급했었다. 시작행의 일부 중 ```요청URL```이 들어있으며 이를 분석하여 요청이 어떤 웹 어플리케이션을 요청한 것인지, 그리고 해당 어플리케이션에 포함된 어떤 서블릿이 해당 요청을 처리하는지가 결정된다.
- 서블릿 컨테이너의 서블릿 관리자는 서블릿을 로드한 후 해당 서블릿의 ```service```메서드를 호출 한다. (```일반적인 상황에서는 HttpServlet의 service 메서드...```)
- 이때 전달받은 매개변수는 해당 메서드의 파라미터인 ServletRequest에 담겨 전달된다.
- 요청 URL의 포맷은 다음과 같다. ```/컨텍스트이름/서블릿매핑URL?매개변수```
- 컨텍스트 이름은 서블릿 컨테이너에 배치된 웹 어플리케이션마다 유일하게 부여된 이름이다.
- 톰캣은 ```webapps```라는 특별한 디렉터리를 감시하다가 해당 디렉터리 아래에 웹 어플리케이션이 있다는 사실을 포착하면 자동으로 배치하는 기능을 제공한다.
- 서블릿 매핑 URL은 웹 어플리케이션이 가진 ```/WEB-INF/web.xml``` 파일에 정의되어 있다.

**병렬처리**

...ing

## 더 알아보기

### 그래서 SpringBoot와 무슨 관계냐!?
- 일반적인 gradle기반의 Spring Boot 프로젝트라면 이 의존성이 들어있다. 
```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
}
```
- 바로 이 ```spring-boot-starter-web``` 안에 ```spring-boot-starter-tomcat```이 존재한다. 이것이 흔히들 말하는 ```내장 톰캣```

**1.💥대략적인 흐름**
1. ```main``` 메서드에서 ```SpringApplication.run``` 호출
2. 웹 애플리케이션 타입이 ```SERVLET```이면(=```spring-boot-starter-web``` 있는 경우) 
   <br/> → ```ServletWebServerApplicationContext``` 생성
3. 이 ```ServletWebServerApplicationContext``` 컨텍스트는 시작하면서 ```ServletWebServerFactory``` 빈을 찾는다.
   <br/> → Tomcat일 경우: ```TomcatServletWebServerFactory```
4. 이 빈들은 ```spring-boot-starter-tomcat```의 ```auto-configuration```에 의해 자동으로 등록
5. ```ServletWebServerFactory```가 실제 내장 서버 인스턴스(Tomcat)를 생성하고, server.port(기본 8080)에 바인딩해서 listen 시작
6. 그 안에 Spring이 ```DispatcherServlet(HttpServlet 구현체)```을 서블릿으로 등록하고, ```@RequestMapping, @GetMapping``` 등으로 선언한 컨트롤러 핸들러들을 매핑

**2.💥전통적인 ```SpringMVC``` vs ```SpringBoot```**
- 바로 이 내장 ```WAS(=Tomcat)```의 유무..
- 전통적인 ```SpringMVC```는 직접 ```DispatcherServlet, ViewResolver, HandlerMapping``` 등을 설정하는 비중이 높다..
- 반면 SpringBoot는 ```spring-boot-autoconfigure```가 자동으로 서블릿 컨테이너, DispatcherServlet, Jackson, Validation, 정적 리소스 핸들러까지 한 번에 세팅
  - 이 ```spring-boot-autoconfigure```는 독립적인 아티팩트이지만 결국 ```spring-boot-starter-web```이 이끌고 오는 전이 의존성
  - ```spring-boot-starter-web``` → ```spring-boot-starter```  → ```spring-boot-autoconfigure``` 이런 순서
  - ```text
    spring-boot-starter-web
    ├─ spring-boot-starter
    │   ├─ spring-boot
    │   └─ spring-boot-autoconfigure   <------------
    ├─ spring-boot-starter-tomcat
    ├─ spring-web
    └─ spring-webmvc
    ```
**3.💥전통적인 ```SpringFrameWork``` Application의 배포**
1. Application을 빌드한 결과물인 ```WAR(Web application ARchive)```파일을 외부 ```WAS(=Tomcat)```의 ```webapps``` 디렉터리 밑에 배치하고
2. ```WAS(=Tomcat)```가 기동시에 그 ```WAR```파일을 인식해서 컨텍스트를 만들고 애플리케이션을 실제로 띄운다.
 <br/>라고 정리할 수 있다.
