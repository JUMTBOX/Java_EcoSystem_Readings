## 1. 웹 서비스 기초

### 1. 서블릿 컨테이너
- 엄밀하게 말해 웹 어플리케이션 서버```(aka. WAS)```는 ```Java EE(Java platform Enterprise Edition)``` 명세를 만족시키는 자바 구현체를 의미하지만,
<br/> 웹 프로그래밍을 위한 미들웨어라는 개념이 일반화 되면서 자바 이외의 프로그래밍 언어로 작성한 서버도 비슷한 역할을 하면 웹 어플리케이션 서버라고 부른다.
- Java EE 가 많은 부분을 포용하려다 보니, 명세 및 구현체가 지나치게 무거워지고 웹 서비스 구현 방식도 필요 이상으로 복잡해졌다는 연유로 스프링 등을 필두로 여러 경량 프레임워크가 인기를 얻었다.
- 하지만 경량 프레임워크도 Java EE 정의 중 웹 어플리케이션 기술위에서 동작하는 것이 일반적이며, 이 기술의 구현체가 이 책에서 살펴볼 서블릿 컨테이너이다.

- 아파치 톰캣, 제티, 그리즐리 등은 서블릿 컨테이너로 현재 널리 사용되고 있다.
- 서블릭 컨테이너의 주요 목표는 서블릿을 동작시키는 데 있다. 따라서 서블릿이 어떤 방식으로 동작하는지 이해하면 서블릿 컨테이너가 제공 해야하는 기능을 역으로 유추할 수 있다.
- 그리고 이런 서블릿의 목적은 HTTP 프로토콜을 사용해 자바로 웹 서비스를 제공하는 것이다.

### 2. HTTP 프로토콜의 실제

#### 아파치 TCPMon ( download: https://archive.apache.org/dist/ws/tcpmon/1.0/tcpmon-1.0-bin.zip )
```bash
# cmd

## 1. 아래 경로(zip 파일 다운로드 후 압축을 푼..)에서 tcpmon.bat 파일 실행 
C:\Users\yjey\Downloads\tcpmon-1.0-bin\tcpmon-1.0-bin\build> tcpmon.bat ## <-- press enter
## 2. 화면에 TCPMon GUI가 노출된다.   
```

- ```하기의 절차를 통해 특정 웹 서버 "www.naver.com" 에 보낸 요청을 가로채 보는 예제```
1. TCPMon GUI 에서 [Listen Port]로 지정된 포트 8000번을 이용해 listen(요청)을 대기
2. 포트 8000번을 통해 받은 요청을 그대로 복제한 후, 포트 80번을 이용해 [Host]로 지정된 ```www.naver.com``` 서버로 전송
3. 그리고 ```www.naver.com``` 서버가 반환한 결과를 받아 "Waiting for Connection"이라 표시된 하단 창에 표시
4. 브라우저를 열고 주소창에 http://localhost:8000 입력 > 네이버 메인 화면 표시

#### HTTP 프로토콜의 간략한 소개
- 기술적인 측면에서 웹 서비스는 HTTP 프로토콜로 메시지를 전송하는 시스템이라 할 수 있다.
- 더 자세히 말하면, 클라이언트가 보낸 메시지는 HTTP 프로토콜에 실려 서블릿 컨테이너에 전송된다.
- 전송된 메시지를 서버 측에서 재구성하려면 서블릿 컨테이너는 반드시 HTTP 프로토콜 해석 기계를 구하여야한다.

**하나의 HTTP 메시지를 특정하는 방법**
```text
1. 다음에 보낼 데이터의 크기를 미리 전송하여 수신측에게 어디까지 읽어야 하는지를 알려주는 방식
2. 종료 기호를 서로 약속한 후 해당 기호로 메시지의 끝을 표시하는 방식
```
- HTTP 프로토콜에서는 ```Content-Length```라는 특별한 값의 메시지 헤더를 사용하여 1번 방식을 지원
- 초기 HTTP 프로토콜은 종료 기호를 사용하여 메시지의 끝을 나타내었다.

**메시지의 내용을 서로 구분하는 행 구분자**
- HTTP는 말 그대로 하이퍼 링크가 포함된 문서를 전송하기 위한 규약에서 시작 되었다. 따라서 HTTP 요청은 원격 기계에 있는 문서의 위치를 지정하는 방법이라 할 수 있다.

**초기 HTTP/0.9 규약**
1. 클라이언트는 요청에 필요한 문자열 뒤에 행 구분자를 붙여 HTTP 요청 메시지를 전송
2. 요청을 받은 서버는 들어온 요청을 한 글자씩 읽다가 행 구분자가 들어오면 요청이 끝난 것으로 인식하고, 그때까지 들어온 데이터를 해석
3. HTTP응답은 종료 기호를 별도로 사용하지 않고, 요청에서 클라이언트가 지정한 문서 데이터(HTML파일)를 서버가 보내고 TCP 커넥션을 종료시켜 클라이언트에 메시지 전송이 완료되었음을 알림

**부가정보 (메시지 헤더와 메시지 바디) - HTTP/1.0**
- 메세지 헤더 중 ```Content-Length``` 헤더값이 지정된 경우 메시지 헤더가 모두 전송된 후에 해당 크기만큼 메시지 바디가 따라나온다는 의미
- 반면 ```Content-Length``` 헤더값이 지정되지 않았다면, 메시지 헤더가 종료된 시점에서 HTTP요청 자체가 종료된 것으로 간주

**HTTP 메시지의 크기를 미리 알 수 없는 경우**
- 동적으로 결과가 변경되는 경우 (ex. 외부 DBMS에 들어있는 데이터를 HTTP 메시지 바디에 지정하는 경우)
  - ```Content-Length``` 헤더 값을 쓰기 위해 메시지 바디를 미리 만든다는 것은 명백히 리소스 낭비이고, 메시지 바디 크기 계산이 끝나기 전까지 최초 응답이 나갈 수 없으므로 느리다. 
  - 전송 버퍼를 사용해 HTTP 바디를 생성하는 도중 버퍼의 크기가 다 차면 해당 내용을 클라이언트로 부분 전송한 이후 다시 버퍼를 재활용하는 편이 더 좋다.
  - 최대한 최초 응답에 걸리는 시간이 짧은 것이 더 나은 설계라 할 수 있다. 그래서 ```HTTP/1.1```에서는 메시지 바디를 점진적으로 전송하는 방식이 추가되었다.

**청크 인코딩**
- 메시지 헤더에 ```transfer-coding```값으로 ```chunked```를 지정하고 메시지 바디에 청크라는 단위의 데이터를 나열하는 방법
- ```Content-Length```헤더에 전체 데이터 크기를 지정하는 것과 비슷하게 전송할 데이터의 크기를 미리 전송하고 데이터를 보내는 전략을 메시지 바디에 적용한 것이다.

#### 첫 번째 HTTP 메시지 분석 - 청크 인코딩
- HTTP 메시지의 각 행은 ```CRLF```로 끝난다는 사실을 기억하라. 따라서 각 행의 마지막에는 ```CRLF```가 생략되어있다.